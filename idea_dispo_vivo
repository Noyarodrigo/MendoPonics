segun chatgpt -> usar la api de iot core que pregunta el estado de los dispo
loopear entre los distintos dispo de la cuenta e ir agregando el estado
agregar el código a la parte de usuario que consulta los dispositivos

codigo:

  from google.oauth2 import service_account
  from google.cloud import iot_v1

	
  # esto habría que loopearlo para que consulte por cada dispo
  # Carga las credenciales de autenticación desde un archivo JSON
  credentials = service_account.Credentials.from_service_account_file('/path/to/credentials.json')
  client = iot_v1.DeviceManagerClient(credentials=credentials)


  project_id = 'my-project-id'
  cloud_region = 'us-central1'
  registry_id = 'my-registry-id'
  device_id = 'my-device-id'

  device_name = client.device_path(project_id, cloud_region, registry_id, device_id)
  device = client.get_device(request={"name": device_name})

  if device.state == 0:
      print("El dispositivo está desconectado")
  else:
      print("El dispositivo está conectado")





@app.route("/user/handler",methods=['GET','POST'])
@login_is_required
def user_handler():
.
.
.

        #this way there's no need to modify variables in the function that is subscribed to the topic
        msg = {'command':'connected',
                'deviceId': str(form_data['deviceid']),
                'deviceRegistryLocation': str(form_data['location']),
                'deviceRegistryId': str(form_data['registry'])}
        data = json.dumps(msg).encode("utf-8")
        topic_path = publisher.topic_path('mendoponics-383115', 'main')
        future = publisher.publish(topic_path, data)
        return redirect('/home')


mandar un mensaje que el command sea 'liveness_probe'

        msg = {'command':'liveness_probe',
                'deviceId': str(form_data['deviceid']),
                'deviceRegistryLocation': str(form_data['location']),
                'deviceRegistryId': str(form_data['registry'])}

al topic main -> lo recibe la function device handler


    if "liveness_probe" in json_data:
        if attributes is None or attributes == '':
            liveness_probe(json.loads(json_data))


le mandamos un mensaje personalizado al dispositivo que incluya
la palabra clave liveness_probe

cambiar los comentarios prints
no hace falta lo de bigquery

#scripts/pubsub-devicehandler/main.py:
  def conf_device(attributes):

      print('attr: ', attributes)
      print(f"Liveness probe Device {attributes['deviceId']} connected, sending configuration")
      client = iot_v1.DeviceManagerClient()
      device_path = client.device_path('mendoponics-383115',attributes['deviceRegistryLocation'], attributes['deviceRegistryId'], attributes['deviceId'])

      bq_client = bigquery.Client()

      query = "SELECT * FROM `mendoponics-383115.main.configurations`\
	      WHERE deviceid = '"+ str(attributes['deviceId']) + \
	      "' LIMIT 1"
      query_job = bq_client.query(query)  # Make an API request.
      result = query_job.result()
      for row in result:
	  data = row
      data_dict = {'timestamp': str(data['timestamp']),
	      'sunrise': data['sunrise'],
	      'sunset':data['sunset'],
	      'pump_interval':data['pump_interval'],
	      'pump_timeon':data['pump_timeon']
	      }
      payload = json.dumps(data_dict)
      print('payload: ',payload)
      return client.send_command_to_device(request={"name": device_path, "binary_data": payload.encode('utf-8')})

le agregamos al arduino un código para que el callback diferencie entre 
la configuracion recibida y el liveness_probe, si es conf que siga como
venia si es livenessprobe que mande un mensaje a nuevo topic liveness

la app va a tener un cliente escuchando ese topic, entonces con un for
preguntamos por cada id y esperamos unos segundos, si llega el mensaje
agregamos a un dict o algo así el estado, si no llega le ponemos false
lo malo es que por cada dispo hay que esperar unos segundos, sino hacer
una pantalla a parte
